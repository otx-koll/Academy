## 상속(inheritance)
- 부모클래스(슈퍼 클래스)에 만들어진 필드, 메소드를 자식클래스(서브클래스)가 물려받음
- extends 키워드 사용
- 상속을 사용함으로써 클래스가 간결해지고, 관리가 용이해지며, 소프트웨어의 생산성이 향상된다.

### 특징
- 클래스의 다중 상속을 지원하지 않는다.
- 상속 횟수 무제한
- 상속의 최상위 조상 클래스는 java.lang.Object 클래스
	- 모든 클래스는 자동으로 java.lang.Object를 상속받는다
	- 자바 컴파일러에 의해 자동으로 이루어짐

### 접근 지정자에서의 상속
- 슈퍼클래스의 private는 다른 모든 클래스에 접근 불퍼. 클래스 내의 멤버들에게만 접근 허용
- 슈퍼클래스의 디폴트는 패키지 내 모든 클래스에 접근 허용
- 슈퍼클래스의 public 은 다른 모든 클래스에 접근 허용
- 슈퍼 클래스의 protected는 같은 패키지 내의 모든 클래스 접근 허용, 다른 패키지에 있어도 서브 클래스는 슈퍼 클래스의 protected 멤버 접근이 가능하다.

### 호출 순서
- 서브 클래스의 생성자가 먼저 호출, 서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

### 생성자 선택
- 서브 클래스 생성자 작성 원칙
	- 서브 클래스 생성자에서 슈퍼 클래스 생성자 하나 선택
- 서브 클래스에서 슈퍼 클래스의 생성자를 선택하지 않는 경우
	- 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자를 선택한다
- 서브 클래스에서 슈퍼 클래스의 생성자를 선택하는 방법
	- super(parameter);
	- 인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
	- 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야한다.

super()를 이용한 사례
```
class B extends A{
public B(int x) { 
	super(x); //첫 줄에 와야함. A클래스의 public A(int x)데 전달
	}
}
```
---

### 업캐스팅(upcasting)
- 서브 클래스 객체를 슈퍼 클래스 타입으로 타입 변환
```
class Person{...}
class Student extends Person{...}

Student s = new Student();
Person p = s; // 업캐스팅, 자동타입변환
```
- 업캐스팅된 레퍼런스
	- 객체 내에 슈퍼 클래스의 멤버만 접근 가능하다.

### 다운캐스팅(downcasting)
- 슈퍼 클래스 객체를 서브 클래스 타입으로 변환
- 개발자의 명시적 타입 변환이 필요하다
```
class Person{...}
class Student extends Person{...}
...
Person p = new Student("이재문"); // 업캐스팅
...
Stduent s = (Student)p; //다운캐스팅, (Student)의 타입 변환 표시 필요
```

### instanceof 연산자
- 업캐스팅된 레퍼런스로 객체의 타입을 판단하기 어렵다.
- 그래서 객체의 타입 식별을 위해 instanceof 연산자를 사용한다.
```
객체레퍼런스 instanceof 클래스타입

연산의 결과 : true/false의 불린 값
```

### 메소드 오버라이딩(Method Overriding)
- 슈퍼 클래스의 메소드를 서브 클래스에서 재정의
	- 이름, 매개변수 타입 및 개수, 리턴 타입 등 다 동일하게 작성
- 동적 바인딩 발생 : 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩

